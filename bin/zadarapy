#!/usr/bin/env python3
# Copyright 2015 Zadara Storage, Inc.
# Originally authored by Jeremy Brown - https://github.com/jwbrown77
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License.  You may obtain a copy
# of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.


import argparse
import sys
from pprint import pprint
from terminaltables import AsciiTable
from zadarapy import drives
from zadarapy import raid_groups
from zadarapy import session

LIMIT_OPTION = {
    'option_positional': ['-l', '--limit'],
    'option_keywords': {
        'dest': 'param_limit',
        'metavar': 'n',
        'type': int,
        'help': 'The maximum number of items to return'
    }
}

INTERVAL_OPTION = {
    'option_positional': ['-I', '--interval'],
    'option_keywords': {
        'dest': 'param_interval',
        'metavar': 'n',
        'type': int,
        'default': 1,
        'help': 'The interval to retrieve statistics for in seconds.  '
                'Default: 1'
    }
}

START_OPTION = {
    'option_positional': ['-s', '--start'],
    'option_keywords': {
        'dest': 'param_start',
        'metavar': 'n',
        'type': int,
        'help': 'The offset to start displaying items from'
    }
}

DRIVE_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_drive_id',
        'metavar': '<volume-xxxxxxxx>',
        'type': str,
        'required': True,
        'help': 'The drive "name" value as returned by "drives list".  For '
                'example: "volume-00002a73".  Required.'
    }
}

RAID_GROUP_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_raid_id',
        'metavar': '<RaidGroup-n>',
        'type': str,
        'required': True,
        'help': 'The RAID group "name" value as returned by "raid-groups '
                'list".  For example: "RaidGroup-1".  Required.'
    }
}

RAID_GROUP_DISPLAY_NAME_OPTION = {
    'option_positional': ['-d', '--display_name'],
    'option_keywords': {
        'dest': 'param_display_name',
        'metavar': 'xxx',
        'type': str,
        'required': True,
        'help': 'The display name to set for the RAID group.  Required.'
    }
}

COMMANDS_DICT = [
    {
        'command_name': 'drives',
        'help': 'Commands related to individual drives',
        'subcommands': [
            {
                'subcommand_info': ('get', drives.get_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION
                ],
                'subcommand_return_key': 'disk',
                'subcommand_help': 'Displays details for a single drive on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list', drives.get_all_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives attached '
                                   'to the VPSA'
            },
            {
                'subcommand_info': ('list-free', drives.get_free_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives '
                                   'available for use on the VPSA (not '
                                   'currently in a RAID group)'
            },
            {
                'subcommand_info': ('performance',
                                    drives.get_drive_performance),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    INTERVAL_OPTION
                ],
                'subcommand_return_key': 'usages',
                'subcommand_help': 'Gets performance statistics for a drive'
            },
            {
                'subcommand_info': ('remove', drives.remove_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Removes an unused drive from the VPSA.'
            },
            {
                'subcommand_info': ('rename', drives.rename_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    {
                        'option_positional': ['-d', '--display_name'],
                        'option_keywords': {
                            'dest': 'param_newname',
                            'metavar': '<display name>',
                            'type': str,
                            'required': True,
                            'help': 'The new display name to set for the '
                                    'drive.  Required.'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Changes the display name for a drive.'
            },
            {
                'subcommand_info': ('replace', drives.replace_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    {
                        'option_positional': ['-t', '--to_drive_id'],
                        'option_keywords': {
                            'dest': 'param_to_drive_id',
                            'metavar': '<volume-xxxxxxxx>',
                            'type': str,
                            'required': True,
                            'help': 'The drive ID of the drive that will '
                                    'will be used as the replacement.  '
                                    'Required.'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Replaces the drive identified by id with '
                                   'the drive identified by display_name.'
            },
            {
                'subcommand_info': ('shred', drives.shred_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Shreds all data on a drive.  THIS ACTION '
                                   'IS IRREVERSIBLE.'
            },
            {
                'subcommand_info': ('shred-cancel',
                                    drives.cancel_shred_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Cancels a currently running shred drive '
                                   'process.'
            }
        ]
    },
    {
        'command_name': 'raid-groups',
        'help': 'Commands related to RAID groups',
        'subcommands': [
            {
                'subcommand_info': ('create', raid_groups.create_raid_group),
                'subcommand_options': [
                    RAID_GROUP_DISPLAY_NAME_OPTION,
                    {
                        'option_positional': ['-D', '--disks'],
                        'option_keywords': {
                            'dest': 'param_disk',
                            'metavar': '<volume-xxxxxxxx,volume-yyyyyyyy>',
                            'type': str,
                            'required': True,
                            'help': 'A comma separated list of drive IDs '
                                    'to use for the RAID group with no '
                                    'spaces.  e.g.: '
                                    '"volume-00000001,volume-00000002".  '
                                    'Required.'
                        }
                    },
                    {
                        'option_positional': ['-p', '--protection'],
                        'option_keywords': {
                            'dest': 'param_protection',
                            'choices': ['RAID1', 'RAID5', 'RAID6'],
                            'type': str,
                            'required': True,
                            'help': 'The RAID type to use.  Required.'
                        }
                    },
                    {
                        'option_positional': ['-s', '--spare'],
                        'option_keywords': {
                            'dest': 'param_hot_spare',
                            'choices': ['YES', 'NO'],
                            'type': str,
                            'default': 'NO',
                            'help': 'Assign a hot spare to the RAID group.  '
                                    'Default: NO'
                        }
                    },
                    {
                        'option_positional': ['-S', '--stripe-size'],
                        'option_keywords': {
                            'dest': 'param_stripe_size',
                            'choices': [4, 16, 32, 64, 128, 256],
                            'type': int,
                            'default': 64,
                            'help': 'The stripe size to use - RAID5 and '
                                    'RAID6 only.  Default: 64'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Creates a new RAID group from provided '
                                   'drives'
            },
            {
                'subcommand_info': ('delete', raid_groups.delete_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Deletes an unused RAID group from the '
                                   'VPSA.'
            },
            {
                'subcommand_info': ('get', raid_groups.get_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION
                ],
                'subcommand_return_key': 'raid_group',
                'subcommand_help': 'Displays details for a single RAID group '
                                   'on the VPSA'
            },
            {
                'subcommand_info': ('hot-spare-add',
                                    raid_groups.add_hot_spare_to_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    {
                        'option_positional': ['-d', '--disk'],
                        'option_keywords': {
                            'dest': 'param_drive_id',
                            'metavar': '<volume-xxxxxxxx>',
                            'type': str,
                            'required': True,
                            'help': 'The drive "name" value as returned by '
                                    '"drives list".  For example: '
                                    '"volume-00002a73".  Required.'
                        }
                    },
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Adds a hot spare to a RAID group using '
                                   'an available drive'
            },
            {
                'subcommand_info': ('hot-spare-remove',
                                    raid_groups.
                                    remove_hot_spare_from_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Removes the hot spare from a RAID group'
            },
            {
                'subcommand_info': ('list', raid_groups.get_all_raid_groups),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'raid_groups',
                'subcommand_help': 'Displays details for all RAID groups on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list-disks',
                                    raid_groups.get_drives_in_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays all disks used in the provided '
                                   'RAID group'
            },
            {
                'subcommand_info': ('list-free',
                                    raid_groups.get_free_raid_groups),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'raid_groups',
                'subcommand_help': 'Displays details for all RAID groups '
                                   'available for use on the VPSA (not '
                                   'currently in a storage pool)'
            },
            {
                'subcommand_info': ('media-scan-pause',
                                    raid_groups.pause_raid_group_media_scan),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Pauses a media scan for a RAID5 or RAID6 '
                                   'RAID group'
            },
            {
                'subcommand_info': ('media-scan-start',
                                    raid_groups.start_raid_group_media_scan),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Starts a media scan for a RAID5 or RAID6 '
                                   'RAID group'
            },
            {
                'subcommand_info': ('performance',
                                    raid_groups.get_raid_group_performance),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    INTERVAL_OPTION
                ],
                'subcommand_return_key': 'usages',
                'subcommand_help': 'Gets performance statistics for a RAID '
                                   'group'
            },
            {
                'subcommand_info': ('rename', raid_groups.rename_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    RAID_GROUP_DISPLAY_NAME_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Changes the display name for a RAID '
                                   'group'
            },
            {
                'subcommand_info': ('repair', raid_groups.repair_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Repairs a RAID group with an available '
                                   'drive'
            },
            {
                'subcommand_info': ('resync-speed',
                                    raid_groups.
                                    update_raid_group_resync_speed),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    {
                        'option_positional': ['--minimum'],
                        'option_keywords': {
                            'dest': 'param_minimum',
                            'metavar': 'n',
                            'type': int,
                            'help': 'The minimum MB/s to resync at'
                        }
                    },
                    {
                        'option_positional': ['--maximum'],
                        'option_keywords': {
                            'dest': 'param_maximum',
                            'metavar': 'n',
                            'type': int,
                            'help': 'The maximum MB/s to resync at'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Updates the speed at which a degraded '
                                   'RAID group will resync'
            }
        ]
    }
]


def format_return(data):
    """
    Format the returned Python dictionary or list of dictionaries into human
    readable format.

    :type data: dict, str
    :param data: The data to be formatted.  This is typically the path to the
        'subcommand_return_key' in the returned dictionary from the API.

    :rtype str
    :return: If a non empty list or dictionary, a human readable table will be
        generated and returned.  If an empty list is detected, a simple
        message will be returned.
    """
    table_data = [[]]

    if type(data) is list:
        if len(data) > 0:
            for key in sorted(data[0]):
                table_data[0].append(key)

            for return_dict in data:
                row = []

                for key in sorted(return_dict):
                    row.append(str(return_dict[key]))

                table_data.append(row)
        else:
            return 'An empty result set was returned'
    else:
        row = []

        for key, value in sorted(data.items()):
            table_data[0].append(key)
            row.append(str(value))

        table_data.append(row)

    return AsciiTable(table_data, 'Count: ' + str(len(table_data) - 1)).table


def main():
    # Parent Parsers
    apiparser = argparse.ArgumentParser(add_help=False)
    group1 = apiparser.add_argument_group('connection arguments',
                                          'Connection options')
    group1.add_argument('-c', '--api-configfile', type=str,
                        dest='configfile',
                        metavar='</path/to/configuration/file>',
                        help='Values such as the API endpoint and API key '
                             'can be parsed from this file, which is in '
                             'INI format.  Defaults to ~/.zadarapy')
    group1.add_argument('-H', '--api-hostname', type=str, dest='host',
                        metavar='<API hostname>',
                        help='The API hostname can be provided here - '
                             'alternatively, it can be defined through '
                             'the ZADARA_HOST environment variable, or a '
                             'configuration file')
    group1.add_argument('--insecure', action='store_true',
                        help='If passed, clear-text HTTP will be used '
                             'instead of encrypted HTTPS')
    group1.add_argument('-j', '--json', action='store_true',
                        help='If passed, a JSON string will be returned '
                             'instead of human readable format')
    group1.add_argument('-k', '--api-key', type=str, dest='key',
                        metavar='<API key>',
                        help='The API key can be provided here -  '
                             'alternatively, it can be defined through '
                             'the ZADARA_KEY environment variable, or a '
                             'configuration file')
    group1.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose output for debugging '
                             'purposes')

    # Main Parser
    parser = argparse.ArgumentParser(
        prog='zadarapy',
        description='%(prog)s is a command line utility that runs commands '
                    'against a storage cloud or VPSA via the REST API using '
                    'the zadarapy Python module'
    )

    parser.add_argument('--version', action='version',
                        version='%(prog)s 0.1',
                        help='Prints the %(prog)s version and exits')

    # Sub Parsers
    commandsparser = parser.add_subparsers(
        title='Commands - run "zadarapy <command> --help" for more '
              'information about each command',
        dest='command',
        metavar='command'
    )

    commandsparser.required = True

    for command in COMMANDS_DICT:
        commandparser = commandsparser.add_parser(command['command_name'],
                                                  description=command['help'],
                                                  help=command['help'])

        if 'subcommands' in command:
            subcommandparser = commandparser.add_subparsers(
                title='Sub Commands - run "zadarapy <command> <subcommand> '
                      '--help for more information about each subcommand',
                metavar='subcommand', dest='subcommand'
            )

            subcommandparser.required = True

            for subcommand in command['subcommands']:
                subcommand_name, _ = subcommand['subcommand_info']
                sub_action = subcommandparser.add_parser(
                    subcommand_name,
                    description=subcommand['subcommand_help'],
                    help=subcommand['subcommand_help'], parents=[apiparser]
                )

                for subcommand_option in subcommand['subcommand_options']:
                    sub_action.add_argument(
                        *subcommand_option['option_positional'],
                        **subcommand_option['option_keywords']
                    )

    # Dispatcher
    parsed_args = vars(parser.parse_args())

    secure = True

    if parsed_args['insecure']:
        secure = False

    try:
        parsed_args['param_session'] = session.Session(
            host=parsed_args['host'],
            key=parsed_args['key'],
            configfile=parsed_args['configfile'],
            secure=secure
        )
    except ValueError as err:
        print('There was an error with a parameter passed to the API: "{0}"'
              .format(err))

    params = {k[6:]: v for k, v in parsed_args.items()
              if k.startswith('param_')}

    if parsed_args['json']:
        params['return_type'] = 'json'

    for command in COMMANDS_DICT:
        if command['command_name'] != parsed_args['command']:
            continue

        if 'subcommands' in command:
            for subcommand in command['subcommands']:
                subcommand_name, subcommand_function = \
                    subcommand['subcommand_info']

                if subcommand_name != parsed_args['subcommand']:
                    continue

                try:
                    if parsed_args['verbose']:
                        if params['session'].zadara_secure:
                            protocol = 'HTTPS'
                        else:
                            protocol = 'HTTP'

                        print('Connecting to {0} with API key {1} over {2}'
                              .format(params['session'].zadara_host,
                                      params['session'].zadara_key,
                                      protocol))

                        print('Parameters sent to the zadarapy function '
                              '"{0}":'.format(subcommand_function.__name__))

                        pprint(params)

                    result = subcommand_function(**params)

                    if parsed_args['json']:
                        print(result)
                    else:
                        if parsed_args['verbose']:
                            print('Raw Python dictionary response:')
                            pprint(result)

                        if subcommand['subcommand_return_key'] is not None:
                            print(format_return(
                                result['response']
                                [subcommand['subcommand_return_key']]
                            ))
                        else:
                            print('Command returned success')

                    sys.exit(0)
                except RuntimeError as err:
                    print('There was an error at runtime returned by the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)
                except ValueError as err:
                    print('There was an error with a parameter passed to the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)


if __name__ == '__main__':
    main()
