#!/usr/bin/env python3
# Copyright 2015 Zadara Storage, Inc.
# Originally authored by Jeremy Brown - https://github.com/jwbrown77
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License.  You may obtain a copy
# of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.


import argparse
import sys
from pprint import pprint
from terminaltables import AsciiTable
from zadarapy import drives
from zadarapy import session

LIMIT_OPTION = {
    'option_positional': ['-l', '--limit'],
    'option_keywords': {
        'dest': 'param_limit',
        'metavar': 'n',
        'type': int,
        'help': 'The maximum number of items to return'
    }
}

START_OPTION = {
    'option_positional': ['-s', '--start'],
    'option_keywords': {
        'dest': 'param_start',
        'metavar': 'n',
        'type': int,
        'help': 'The offset to start displaying items from'
    }
}

COMMANDS_DICT = [
    {
        'command_name': 'drives',
        'help': 'Commands related to individual drives',
        'subcommands': [
            {
                'subcommand_info': ('get', drives.get_drive),
                'subcommand_options': [
                    {
                        'option_positional': ['-i', '--id'],
                        'option_keywords': {
                            'dest': 'param_drive_id',
                            'metavar': '<volume-xxxxxxxx>',
                            'type': str,
                            'required': True,
                            'help': 'The drive "name" value as returned by '
                                    '"drives list".  For example: '
                                    '"volume-00002a73".  Required.'
                        }
                    }
                ],
                'subcommand_return_key': 'disk',
                'subcommand_help': 'Displays details for a single drive on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list', drives.get_all_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives attached '
                                   'to the VPSA'
            },
            {
                'subcommand_info': ('list-free', drives.get_free_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives '
                                   'available for use on the VPSA (not '
                                   'currently in a RAID group)'
            }
        ]
    }
]


def format_return(data):
    """
    Format the returned Python dictionary or list of dictionaries into human
    readable format.

    :type data: dict, str
    :param data: The data to be formatted.  This is typically the path to the
        'subcommand_return_key' in the returned dictionary from the API.

    :rtype str
    :return: If a non empty list or dictionary, a human readable table will be
        generated and returned.  If an empty list is detected, a simple
        message will be returned.
    """
    table_data = [[]]

    if type(data) is list:
        if len(data) > 0:
            for key in sorted(data[0]):
                table_data[0].append(key)

            for return_dict in data:
                row = []

                for key in sorted(return_dict):
                    row.append(str(return_dict[key]))

                table_data.append(row)
        else:
            return 'An empty result set was returned'
    else:
        row = []

        for key, value in sorted(data.items()):
            table_data[0].append(key)
            row.append(str(value))

        table_data.append(row)

    return AsciiTable(table_data).table


def main():
    # Parent Parsers
    apiparser = argparse.ArgumentParser(add_help=False)
    group1 = apiparser.add_argument_group('connection arguments',
                                          'Connection options')
    group1.add_argument('-c', '--api-configfile', type=str,
                        dest='configfile',
                        metavar='</path/to/configuration/file>',
                        help='Values such as the API endpoint and API key '
                             'can be parsed from this file, which is in '
                             'INI format.  Defaults to ~/.zadarapy')
    group1.add_argument('-H', '--api-hostname', type=str, dest='host',
                        metavar='<API hostname>',
                        help='The API hostname can be provided here - '
                             'alternatively, it can be defined through '
                             'the ZADARA_HOST environment variable, or a '
                             'configuration file')
    group1.add_argument('--insecure', action='store_true',
                        help='If passed, clear-text HTTP will be used '
                             'instead of encrypted HTTPS')
    group1.add_argument('-j', '--json', action='store_true',
                        help='If passed, a JSON string will be returned '
                             'instead of human readable format')
    group1.add_argument('-k', '--api-key', type=str, dest='key',
                        metavar='<API key>',
                        help='The API key can be provided here -  '
                             'alternatively, it can be defined through '
                             'the ZADARA_KEY environment variable, or a '
                             'configuration file')
    group1.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose output for debugging '
                             'purposes')

    # Main Parser
    parser = argparse.ArgumentParser(
        prog='zadarapy',
        description='%(prog)s is a command line utility that runs commands '
                    'against a storage cloud or VPSA via the REST API using '
                    'the zadarapy Python module'
    )

    parser.add_argument('--version', action='version',
                        version='%(prog)s 0.1',
                        help='Prints the %(prog)s version and exits')

    # Sub Parsers
    commandsparser = parser.add_subparsers(
        title='Commands - run "zadarapy <command> --help" for more '
              'information about each command',
        dest='command',
        metavar='command'
    )

    commandsparser.required = True

    for command in COMMANDS_DICT:
        commandparser = commandsparser.add_parser(command['command_name'],
                                                  description=command['help'],
                                                  help=command['help'])

        if 'subcommands' in command:
            subcommandparser = commandparser.add_subparsers(
                title='Sub Commands - run "zadarapy <command> <subcommand> '
                      '--help for more information about each subcommand',
                metavar='subcommand', dest='subcommand'
            )

            subcommandparser.required = True

            for subcommand in command['subcommands']:
                subcommand_name, _ = subcommand['subcommand_info']
                sub_action = subcommandparser.add_parser(
                    subcommand_name,
                    description=subcommand['subcommand_help'],
                    help=subcommand['subcommand_help'], parents=[apiparser]
                )

                for subcommand_option in subcommand['subcommand_options']:
                    sub_action.add_argument(
                        *subcommand_option['option_positional'],
                        **subcommand_option['option_keywords']
                    )

    # Dispatcher
    parsed_args = vars(parser.parse_args())

    secure = True

    if parsed_args['insecure']:
        secure = False

    try:
        parsed_args['param_session'] = session.Session(
            host=parsed_args['host'],
            key=parsed_args['key'],
            configfile=parsed_args['configfile'],
            secure=secure
        )
    except ValueError as err:
        print('There was an error with a parameter passed to the API: "{0}"'
              .format(err))

    params = {k[6:]: v for k, v in parsed_args.items()
              if k.startswith('param_')}

    if parsed_args['json']:
        params['return_type'] = 'json'

    for command in COMMANDS_DICT:
        if command['command_name'] != parsed_args['command']:
            continue

        if 'subcommands' in command:
            for subcommand in command['subcommands']:
                subcommand_name, subcommand_function = \
                    subcommand['subcommand_info']

                if subcommand_name != parsed_args['subcommand']:
                    continue

                try:
                    if parsed_args['verbose']:
                        if params['session'].zadara_secure:
                            protocol = 'HTTPS'
                        else:
                            protocol = 'HTTP'

                        print('Connecting to {0} with API key {1} over {2}'
                              .format(params['session'].zadara_host,
                                      params['session'].zadara_key,
                                      protocol))

                        print('Parameters sent to the zadarapy function '
                              '"{0}":'.format(subcommand_function.__name__))

                        pprint(params)

                    result = subcommand_function(**params)

                    if parsed_args['json']:
                        print(result)
                    else:
                        if parsed_args['verbose']:
                            print('Raw Python dictionary response:')
                            pprint(result)

                        print(format_return(
                            result['response']
                            [subcommand['subcommand_return_key']]
                        ))

                    sys.exit(0)
                except RuntimeError as err:
                    print('There was an error at runtime returned by the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)
                except ValueError as err:
                    print('There was an error with a parameter passed to the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)


if __name__ == '__main__':
    main()
