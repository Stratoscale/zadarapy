#!/usr/bin/env python3
# Copyright 2015 Zadara Storage, Inc.
# Originally authored by Jeremy Brown - https://github.com/jwbrown77
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License.  You may obtain a copy
# of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.


import argparse
import sys
from pprint import pprint
from terminaltables import AsciiTable
from terminaltables import SingleTable
from zadarapy import drives
from zadarapy import pools
from zadarapy import raid_groups
from zadarapy import session
from zadarapy import volumes

CAPACITY_OPTION = {
    'option_positional': ['-C', '--capacity'],
    'option_keywords': {
        'dest': 'param_capacity',
        'metavar': '<n>',
        'type': int,
        'required': True,
        'help': 'The capacity in GB to create/expand by.  Required.'
    }
}

DISPLAY_NAME_OPTION = {
    'option_positional': ['-d', '--display_name'],
    'option_keywords': {
        'dest': 'param_display_name',
        'metavar': '<xxx>',
        'type': str,
        'required': True,
        'help': 'The display name to set for the item.  Required.'
    }
}

LIMIT_OPTION = {
    'option_positional': ['-l', '--limit'],
    'option_keywords': {
        'dest': 'param_limit',
        'metavar': '<n>',
        'type': int,
        'help': 'The maximum number of items to return'
    }
}

INTERVAL_OPTION = {
    'option_positional': ['-I', '--interval'],
    'option_keywords': {
        'dest': 'param_interval',
        'metavar': '<n>',
        'type': int,
        'default': 1,
        'help': 'The interval to retrieve statistics for in seconds.  '
                'Default: 1'
    }
}

START_OPTION = {
    'option_positional': ['-s', '--start'],
    'option_keywords': {
        'dest': 'param_start',
        'metavar': '<n>',
        'type': int,
        'help': 'The offset to start displaying items from'
    }
}

DRIVE_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_drive_id',
        'metavar': '<volume-xxxxxxxx>',
        'type': str,
        'required': True,
        'help': 'The drive "name" value as returned by "drives list".  For '
                'example: "volume-00002a73".  Required.'
    }
}

POOL_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_pool_id',
        'metavar': '<pool-xxxxxxxx>',
        'type': str,
        'required': True,
        'help': 'The storage pool "name" value as returned by "pools list".  '
                'For example: "pool-00000001".  Required.'
    }
}

POOL_RAID_GROUPS_OPTION = {
    'option_positional': ['-r', '--raid-groups'],
    'option_keywords': {
        'dest': 'param_raid_groups',
        'metavar': '<RaidGroup-n,RaidGroup-n>',
        'type': str,
        'required': True,
        'help': 'A comma separated list of RAID groups to use for the '
                'storage pool with no spaces.  e.g.: '
                '"RaidGroup-3,RaidGroup-4".  Required.'
    }
}

POOL_CACHE_OPTION = {
    'option_positional': ['--cache'],
    'option_keywords': {
        'dest': 'param_cache',
        'choices': ['YES', 'NO'],
        'type': str,
        'required': True,
        'help': 'Toggles the storage pool SSD cache.  Required.'
    }
}

RAID_GROUP_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_raid_id',
        'metavar': '<RaidGroup-n>',
        'type': str,
        'required': True,
        'help': 'The RAID group "name" value as returned by "raid-groups '
                'list".  For example: "RaidGroup-1".  Required.'
    }
}

VOLUME_ID_OPTION = {
    'option_positional': ['-i', '--id'],
    'option_keywords': {
        'dest': 'param_volume_id',
        'metavar': '<volume-xxxxxxxx>',
        'type': str,
        'required': True,
        'help': 'The volume "name" value as returned by "volume list".  For '
                'example: "volume-00000001".  Required.'
    }
}

VOLUME_BLOCK_OPTION = {
    'option_positional': ['-b', '--block'],
    'option_keywords': {
        'dest': 'param_block',
        'choices': ['YES', 'NO'],
        'type': str,
        'required': True,
        'help': 'If YES, the volume will be block (iSCSI/iSER).  If NO, it '
                'will be a NAS volume (NFS/SMB).  Required.'
    }
}

VOLUME_ATTACHPOLICIES_OPTION = {
    'option_positional': ['-a', '--attachpolicies'],
    'option_keywords': {
        'dest': 'param_attachpolicies',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'YES',
        'help': 'If YES, the default snapshot policies for the VPSA will be '
                'attached.  If NO, no snapshot policies will be assigned.  '
                'Default: YES'
    }
}

VOLUME_EXPORT_NAME_OPTION = {
    'option_positional': ['-e', '--export-name'],
    'option_keywords': {
        'dest': 'param_export_name',
        'metavar': '<xxx>',
        'type': str,
        'help': 'If set, the last part of the NFS/SMB export path will be '
                'set to this value.  If not set, display_name will be used.'
    }
}

VOLUME_ATIMEUPDATE_OPTION = {
    'option_positional': ['--atimeupdate'],
    'option_keywords': {
        'dest': 'param_atimeupdate',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'If YES, NAS shares will updated last accessed time each '
                'time a file is accessed (impacts performance).  Default: NO'
    }
}

VOLUME_SMBONLY_OPTION = {
    'option_positional': ['--smbonly'],
    'option_keywords': {
        'dest': 'param_smbonly',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'If YES, NAS shares will be accessible only via SMB '
                '(improves performance).  Default: NO'
    }
}

VOLUME_SMBGUEST_OPTION = {
    'option_positional': ['--smbguest'],
    'option_keywords': {
        'dest': 'param_smbguest',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'If YES, authentication will not be required to login to and '
                'read/write from/to a SMB share.  Default: NO'
    }
}

VOLUME_SMBWINDOWSACL_OPTION = {
    'option_positional': ['--smbwindowsacl'],
    'option_keywords': {
        'dest': 'param_smbwindowsacl',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'If YES, extended ACLs will be enabled for SMB shares.  '
                'Default: NO'
    }
}

VOLUME_SMBFILECREATEMASK_OPTION = {
    'option_positional': ['--smbfilecreatemask'],
    'option_keywords': {
        'dest': 'param_smbfilecreatemask',
        'metavar': '<nnnn>',
        'type': str,
        'default': '0744',
        'help': 'For NAS shares, the permissions assigned to new files '
                'created through SMB shares.  Default: 0744'
    }
}

VOLUME_SMBDIRCREATEMASK_OPTION = {
    'option_positional': ['--smbdircreatemask'],
    'option_keywords': {
        'dest': 'param_smbdircreatemask',
        'metavar': '<nnnn>',
        'type': str,
        'default': '0755',
        'help': 'For NAS shares, the permissions assigned to new directories '
                'created through SMB shares.  Default: 0755'
    }
}

VOLUME_SMBMAPARCHIVE_OPTION = {
    'option_positional': ['--smbmaparchive'],
    'option_keywords': {
        'dest': 'param_smbmaparchive',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'YES',
        'help': 'For NAS shares, when using SMB, if YES, a file\'s execute '
                'bit will be used to flag the Archive file attribute.  '
                'Default: YES'
    }
}

VOLUME_SMBAIOSIZE_OPTION = {
    'option_positional': ['--smbaiosize'],
    'option_keywords': {
        'dest': 'param_smbaiosize',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'For NAS shares, when using SMB, if YES, file reads will be '
                'performed asynchronously, which improves performance for '
                'some workloads.  Default: NO'
    }
}

VOLUME_NFSROOTSQUASH_OPTION = {
    'option_positional': ['--nfsrootsquash'],
    'option_keywords': {
        'dest': 'param_nfsrootsquash',
        'choices': ['YES', 'NO'],
        'type': str,
        'default': 'NO',
        'help': 'For NAS shares, when using NFS, if YES, root squash is  '
                'enabled.  Default: NO'
    }
}

COMMANDS_DICT = [
    {
        'command_name': 'drives',
        'help': 'Commands related to individual drives',
        'subcommands': [
            {
                'subcommand_info': ('get', drives.get_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION
                ],
                'subcommand_return_key': 'disk',
                'subcommand_help': 'Displays details for a single drive on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list', drives.get_all_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives attached '
                                   'to the VPSA'
            },
            {
                'subcommand_info': ('list-free', drives.get_free_drives),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays details for all drives '
                                   'available for use on the VPSA (not '
                                   'currently in a RAID group)'
            },
            {
                'subcommand_info': ('performance',
                                    drives.get_drive_performance),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    INTERVAL_OPTION
                ],
                'subcommand_return_key': 'usages',
                'subcommand_help': 'Gets performance statistics for a drive'
            },
            {
                'subcommand_info': ('remove', drives.remove_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Removes an unused drive from the VPSA.'
            },
            {
                'subcommand_info': ('rename', drives.rename_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    DISPLAY_NAME_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Changes the display name for a drive.'
            },
            {
                'subcommand_info': ('replace', drives.replace_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                    {
                        'option_positional': ['-t', '--to_drive_id'],
                        'option_keywords': {
                            'dest': 'param_to_drive_id',
                            'metavar': '<volume-xxxxxxxx>',
                            'type': str,
                            'required': True,
                            'help': 'The drive ID of the drive that will '
                                    'will be used as the replacement.  '
                                    'Required.'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Replaces the drive identified by id with '
                                   'the drive identified by display_name.'
            },
            {
                'subcommand_info': ('shred', drives.shred_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Shreds all data on a drive.  THIS ACTION '
                                   'IS IRREVERSIBLE.'
            },
            {
                'subcommand_info': ('shred-cancel',
                                    drives.cancel_shred_drive),
                'subcommand_options': [
                    DRIVE_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Cancels a currently running shred drive '
                                   'process.'
            }
        ]
    },
    {
        'command_name': 'pools',
        'help': 'Commands related to storage pools',
        'subcommands': [
            {
                'subcommand_info': ('cache', pools.set_pool_cache),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    POOL_CACHE_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Toggles the SSD caching for a pool'
            },
            {
                'subcommand_info': ('capacity-alerts',
                                    pools.update_pool_capacity_alerts),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    {
                        'option_positional': ['-C', '--capacityhistory'],
                        'option_keywords': {
                            'dest': 'param_capacityhistory',
                            'metavar': '<n>',
                            'type': int,
                            'help': 'The number of minutes used to calculate '
                                    'pool exhaustion.'
                        }
                    },
                    {
                        'option_positional': ['-a', '--alertmode'],
                        'option_keywords': {
                            'dest': 'param_alertmode',
                            'metavar': '<n>',
                            'type': int,
                            'help': 'The number of minutes before the '
                                    'storage pool is predicted to reach '
                                    'space exhaustion'
                        }
                    },
                    {
                        'option_positional': ['-p', '--protectedmode'],
                        'option_keywords': {
                            'dest': 'param_protectedmode',
                            'metavar': '<n>',
                            'type': int,
                            'help': 'The number of minutes until pool space '
                                    'exhaustion before protected mode is '
                                    'enabled'
                        }
                    },
                    {
                        'option_positional': ['-e', '--emergencymode'],
                        'option_keywords': {
                            'dest': 'param_emergencymode',
                            'metavar': '<n>',
                            'type': int,
                            'help': 'Start deleting old snapshots when '
                                    'number of GB free is under this value'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Change capacity alert settings'
            },
            {
                'subcommand_info': ('create', pools.create_pool),
                'subcommand_options': [
                    DISPLAY_NAME_OPTION,
                    POOL_RAID_GROUPS_OPTION,
                    CAPACITY_OPTION,
                    {
                        'option_positional': ['-p', '--pooltype'],
                        'option_keywords': {
                            'dest': 'param_pooltype',
                            'choices': ['OLTP', 'Repository',
                                        'Transactional'],
                            'type': str,
                            'required': True,
                            'help': 'The storage pool type to create.  '
                                    'Required.'
                        }
                    },
                    POOL_CACHE_OPTION,
                    {
                        'option_positional': ['-m', '--mode'],
                        'option_keywords': {
                            'dest': 'param_mode',
                            'choices': ['simple', 'stripe'],
                            'type': str,
                            'default': 'stripe',
                            'help': 'The storage pool striping mode to use.  '
                                    'Default: stripe'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Creates a new storage pool'
            },
            {
                'subcommand_info': ('delete', pools.delete_pool),
                'subcommand_options': [
                    POOL_ID_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Deletes a storage pool'
            },
            {
                'subcommand_info': ('expand', pools.add_raid_groups_to_pool),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    POOL_RAID_GROUPS_OPTION,
                    CAPACITY_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Expands a storage pool with the provided '
                                   'RAID groups'
            },
            {
                'subcommand_info': ('get', pools.get_pool),
                'subcommand_options': [
                    POOL_ID_OPTION
                ],
                'subcommand_return_key': 'pool',
                'subcommand_help': 'Displays details for a single storage '
                                   'pool on the VPSA'
            },
            {
                'subcommand_info': ('list', pools.get_all_pools),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'pools',
                'subcommand_help': 'Displays details for all storage pools '
                                   'on the VPSA'
            },

            {
                'subcommand_info': ('list-raid-groups',
                                    pools.get_raid_groups_in_pool),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'raid_groups',
                'subcommand_help': 'Displays all RAID groups in the storage '
                                   'pool'
            },
            {
                'subcommand_info': ('list-volumes',
                                    pools.get_volumes_in_pool),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'volumes',
                'subcommand_help': 'Displays all volumes in the storage pool'
            },
            {
                'subcommand_info': ('list-volumes-mirror',
                                    pools.
                                    get_pool_mirror_destination_volumes),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'volumes',
                'subcommand_help': 'Displays all mirror destination volumes '
                                   'in the storage pool'
            },
            {
                'subcommand_info': ('list-volumes-recycle-bin',
                                    pools.get_volumes_in_pool_recycle_bin),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'volumes',
                'subcommand_help': 'Displays all volumes currently in the '
                                   'pool\'s recycle bin'
            },
            {
                'subcommand_info': ('performance',
                                    pools.get_pool_performance),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    INTERVAL_OPTION
                ],
                'subcommand_return_key': 'usages',
                'subcommand_help': 'Gets performance statistics for a '
                                   'storage pool'
            },
            {
                'subcommand_info': ('rename', pools.rename_pool),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    DISPLAY_NAME_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Changes the display name for a storage '
                                   'pool'
            }
        ],
    },
    {
        'command_name': 'raid-groups',
        'help': 'Commands related to RAID groups',
        'subcommands': [
            {
                'subcommand_info': ('create', raid_groups.create_raid_group),
                'subcommand_options': [
                    DISPLAY_NAME_OPTION,
                    {
                        'option_positional': ['-D', '--disks'],
                        'option_keywords': {
                            'dest': 'param_disk',
                            'metavar': '<volume-xxxxxxxx,volume-yyyyyyyy>',
                            'type': str,
                            'required': True,
                            'help': 'A comma separated list of drive IDs '
                                    'to use for the RAID group with no '
                                    'spaces.  e.g.: '
                                    '"volume-00000001,volume-00000002".  '
                                    'Required.'
                        }
                    },
                    {
                        'option_positional': ['-p', '--protection'],
                        'option_keywords': {
                            'dest': 'param_protection',
                            'choices': ['RAID1', 'RAID5', 'RAID6'],
                            'type': str,
                            'required': True,
                            'help': 'The RAID type to use.  Required.'
                        }
                    },
                    {
                        'option_positional': ['-s', '--spare'],
                        'option_keywords': {
                            'dest': 'param_hot_spare',
                            'choices': ['YES', 'NO'],
                            'type': str,
                            'default': 'NO',
                            'help': 'Assign a hot spare to the RAID group.  '
                                    'Default: NO'
                        }
                    },
                    {
                        'option_positional': ['-S', '--stripe-size'],
                        'option_keywords': {
                            'dest': 'param_stripe_size',
                            'choices': [4, 16, 32, 64, 128, 256],
                            'type': int,
                            'default': 64,
                            'help': 'The stripe size to use - RAID5 and '
                                    'RAID6 only.  Default: 64'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Creates a new RAID group from provided '
                                   'drives'
            },
            {
                'subcommand_info': ('delete', raid_groups.delete_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Deletes an unused RAID group from the '
                                   'VPSA.'
            },
            {
                'subcommand_info': ('get', raid_groups.get_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION
                ],
                'subcommand_return_key': 'raid_group',
                'subcommand_help': 'Displays details for a single RAID group '
                                   'on the VPSA'
            },
            {
                'subcommand_info': ('hot-spare-add',
                                    raid_groups.add_hot_spare_to_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    {
                        'option_positional': ['-d', '--disk'],
                        'option_keywords': {
                            'dest': 'param_drive_id',
                            'metavar': '<volume-xxxxxxxx>',
                            'type': str,
                            'required': True,
                            'help': 'The drive "name" value as returned by '
                                    '"drives list".  For example: '
                                    '"volume-00002a73".  Required.'
                        }
                    },
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Adds a hot spare to a RAID group using '
                                   'an available drive'
            },
            {
                'subcommand_info': ('hot-spare-remove',
                                    raid_groups.
                                    remove_hot_spare_from_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Removes the hot spare from a RAID group'
            },
            {
                'subcommand_info': ('list', raid_groups.get_all_raid_groups),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'raid_groups',
                'subcommand_help': 'Displays details for all RAID groups on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list-disks',
                                    raid_groups.get_drives_in_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'disks',
                'subcommand_help': 'Displays all disks used in the provided '
                                   'RAID group'
            },
            {
                'subcommand_info': ('list-free',
                                    raid_groups.get_free_raid_groups),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'raid_groups',
                'subcommand_help': 'Displays details for all RAID groups '
                                   'available for use on the VPSA (not '
                                   'currently in a storage pool)'
            },
            {
                'subcommand_info': ('media-scan-pause',
                                    raid_groups.pause_raid_group_media_scan),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Pauses a media scan for a RAID5 or RAID6 '
                                   'RAID group'
            },
            {
                'subcommand_info': ('media-scan-start',
                                    raid_groups.start_raid_group_media_scan),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Starts a media scan for a RAID5 or RAID6 '
                                   'RAID group'
            },
            {
                'subcommand_info': ('performance',
                                    raid_groups.get_raid_group_performance),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    INTERVAL_OPTION
                ],
                'subcommand_return_key': 'usages',
                'subcommand_help': 'Gets performance statistics for a RAID '
                                   'group'
            },
            {
                'subcommand_info': ('rename', raid_groups.rename_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    DISPLAY_NAME_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Changes the display name for a RAID '
                                   'group'
            },
            {
                'subcommand_info': ('repair', raid_groups.repair_raid_group),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Repairs a RAID group with an available '
                                   'drive'
            },
            {
                'subcommand_info': ('resync-speed',
                                    raid_groups.
                                    update_raid_group_resync_speed),
                'subcommand_options': [
                    RAID_GROUP_ID_OPTION,
                    {
                        'option_positional': ['--minimum'],
                        'option_keywords': {
                            'dest': 'param_minimum',
                            'metavar': 'n',
                            'type': int,
                            'help': 'The minimum MB/s to resync at'
                        }
                    },
                    {
                        'option_positional': ['--maximum'],
                        'option_keywords': {
                            'dest': 'param_maximum',
                            'metavar': 'n',
                            'type': int,
                            'help': 'The maximum MB/s to resync at'
                        }
                    }
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Updates the speed at which a degraded '
                                   'RAID group will resync'
            }
        ]
    },
    {
        'command_name': 'volumes',
        'help': 'Commands related to volumes',
        'subcommands': [
            {
                'subcommand_info': ('create', volumes.create_volume),
                'subcommand_options': [
                    POOL_ID_OPTION,
                    DISPLAY_NAME_OPTION,
                    CAPACITY_OPTION,
                    VOLUME_BLOCK_OPTION,
                    VOLUME_ATTACHPOLICIES_OPTION,
                    {
                        'option_positional': ['--crypt'],
                        'option_keywords': {
                            'dest': 'param_crypt',
                            'choices': ['YES', 'NO'],
                            'type': str,
                            'default': 'NO',
                            'help': 'If YES, encryption will be enabled '
                                    'using the VPSA encryption key defined '
                                    'by the user.  If NO, encryption will '
                                    'not be enabled.  Default: NO'
                        }
                    },
                    VOLUME_EXPORT_NAME_OPTION,
                    VOLUME_ATIMEUPDATE_OPTION,
                    VOLUME_SMBONLY_OPTION,
                    VOLUME_SMBGUEST_OPTION,
                    VOLUME_SMBWINDOWSACL_OPTION,
                    VOLUME_SMBFILECREATEMASK_OPTION,
                    VOLUME_SMBDIRCREATEMASK_OPTION,
                    VOLUME_SMBMAPARCHIVE_OPTION,
                    VOLUME_SMBAIOSIZE_OPTION,
                    VOLUME_NFSROOTSQUASH_OPTION
                ],
                'subcommand_return_key': None,
                'subcommand_help': 'Creates a new volume on the provided pool'
            },
            {
                'subcommand_info': ('get', volumes.get_volume),
                'subcommand_options': [
                    VOLUME_ID_OPTION
                ],
                'subcommand_return_key': 'volume',
                'subcommand_help': 'Displays details for a single volume on '
                                   'the VPSA'
            },
            {
                'subcommand_info': ('list', volumes.get_all_volumes),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'volumes',
                'subcommand_help': 'Displays details for all volumes on the '
                                   'VPSA'
            },
            {
                'subcommand_info': ('list-free', volumes.get_free_volumes),
                'subcommand_options': [
                    LIMIT_OPTION,
                    START_OPTION
                ],
                'subcommand_return_key': 'volumes',
                'subcommand_help': 'Displays details for all volumes not '
                                   'currently attached to any servers'
            }
        ]
    }
]


def format_return(data, vertical=False):
    """
    Format the returned Python dictionary or list of dictionaries into human
    readable format.

    :type data: dict, list
    :param data: The data to be formatted.  This is typically the path to the
        'subcommand_return_key' in the returned dictionary from the API.

    :type vertical: bool
    :param vertical: If True, output will be displayed in a vertical format.
        This makes the output of large amount of columns easier to read.

    :rtype list
    :return: If a non empty list or dictionary, a human readable table will be
        generated and returned.  If an empty list is detected, a simple
        message will be returned.
    """
    if vertical:
        table_data = []
        table_formatted = []

        if type(data) is list:
            if len(data) > 0:
                for return_dict in data:
                    items = []
                    for key, value in sorted(return_dict.items()):
                        items.append([str(key), str(value)])
                    table_data.append(items)
            else:
                return 'An empty result set was returned'
        else:
            items = []
            for key, value in sorted(data.items()):
                items.append([str(key), str(value)])

            table_data.append(items)

        for row in table_data:
            table = SingleTable(row)
            table.inner_heading_row_border = False
            title = None
            for item in row:
                if item[0] == 'name':
                    title = item[1]
            if title is not None:
                table.title = title
            table_formatted.append(table.table)

        return table_formatted
    else:
        table_data = [[]]

        if type(data) is list:
            if len(data) > 0:
                for key in sorted(data[0]):
                    table_data[0].append(key)

                for return_dict in data:
                    row = []

                    for key in sorted(return_dict):
                        row.append(str(return_dict[key]))

                    table_data.append(row)
            else:
                return 'An empty result set was returned'
        else:
            row = []

            for key, value in sorted(data.items()):
                table_data[0].append(key)
                row.append(str(value))

            table_data.append(row)

        return [AsciiTable(
            table_data, 'Count: ' + str(len(table_data) - 1)
        ).table]


def main():
    # Parent Parsers
    apiparser = argparse.ArgumentParser(add_help=False)
    group1 = apiparser.add_argument_group('connection arguments',
                                          'Connection options')
    group1.add_argument('-c', '--api-configfile', type=str,
                        dest='configfile',
                        metavar='</path/to/configuration/file>',
                        help='Values such as the API endpoint and API key '
                             'can be parsed from this file, which is in '
                             'INI format.  Defaults to ~/.zadarapy')
    group1.add_argument('-H', '--api-hostname', type=str, dest='host',
                        metavar='<API hostname>',
                        help='The API hostname can be provided here - '
                             'alternatively, it can be defined through '
                             'the ZADARA_HOST environment variable, or a '
                             'configuration file')
    group1.add_argument('--insecure', action='store_true',
                        help='If passed, clear-text HTTP will be used '
                             'instead of encrypted HTTPS')
    group1.add_argument('-j', '--json', action='store_true',
                        help='If passed, a JSON string will be returned '
                             'instead of human readable format')
    group1.add_argument('-k', '--api-key', type=str, dest='key',
                        metavar='<API key>',
                        help='The API key can be provided here -  '
                             'alternatively, it can be defined through '
                             'the ZADARA_KEY environment variable, or a '
                             'configuration file')
    group1.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose output for debugging '
                             'purposes')
    group1.add_argument('--vertical', action='store_true',
                        help='Enable verbose output for debugging '
                             'purposes')

    # Main Parser
    parser = argparse.ArgumentParser(
        prog='zadarapy',
        description='%(prog)s is a command line utility that runs commands '
                    'against a storage cloud or VPSA via the REST API using '
                    'the zadarapy Python module'
    )

    parser.add_argument('--version', action='version',
                        version='%(prog)s 0.1',
                        help='Prints the %(prog)s version and exits')

    # Sub Parsers
    commandsparser = parser.add_subparsers(
        title='Commands - run "zadarapy <command> --help" for more '
              'information about each command',
        dest='command',
        metavar='command'
    )

    commandsparser.required = True

    for command in COMMANDS_DICT:
        commandparser = commandsparser.add_parser(command['command_name'],
                                                  description=command['help'],
                                                  help=command['help'])

        if 'subcommands' in command:
            subcommandparser = commandparser.add_subparsers(
                title='Sub Commands - run "zadarapy <command> <subcommand> '
                      '--help for more information about each subcommand',
                metavar='subcommand', dest='subcommand'
            )

            subcommandparser.required = True

            for subcommand in command['subcommands']:
                subcommand_name, _ = subcommand['subcommand_info']
                sub_action = subcommandparser.add_parser(
                    subcommand_name,
                    description=subcommand['subcommand_help'],
                    help=subcommand['subcommand_help'], parents=[apiparser]
                )

                for subcommand_option in subcommand['subcommand_options']:
                    sub_action.add_argument(
                        *subcommand_option['option_positional'],
                        **subcommand_option['option_keywords']
                    )

    # Dispatcher
    parsed_args = vars(parser.parse_args())

    secure = True

    if parsed_args['insecure']:
        secure = False

    try:
        parsed_args['param_session'] = session.Session(
            host=parsed_args['host'],
            key=parsed_args['key'],
            configfile=parsed_args['configfile'],
            secure=secure
        )
    except ValueError as err:
        print('There was an error with a parameter passed to the API: "{0}"'
              .format(err))

    params = {k[6:]: v for k, v in parsed_args.items()
              if k.startswith('param_')}

    if parsed_args['json']:
        params['return_type'] = 'json'

    for command in COMMANDS_DICT:
        if command['command_name'] != parsed_args['command']:
            continue

        if 'subcommands' in command:
            for subcommand in command['subcommands']:
                subcommand_name, subcommand_function = \
                    subcommand['subcommand_info']

                if subcommand_name != parsed_args['subcommand']:
                    continue

                try:
                    if parsed_args['verbose']:
                        if params['session'].zadara_secure:
                            protocol = 'HTTPS'
                        else:
                            protocol = 'HTTP'

                        print('Connecting to {0} with API key {1} over {2}'
                              .format(params['session'].zadara_host,
                                      params['session'].zadara_key,
                                      protocol))

                        print('Parameters sent to the zadarapy function '
                              '"{0}":'.format(subcommand_function.__name__))

                        pprint(params)

                    result = subcommand_function(**params)

                    if parsed_args['json']:
                        print(result)
                    else:
                        if parsed_args['verbose']:
                            print('Raw Python dictionary response:')
                            pprint(result)

                        if subcommand['subcommand_return_key'] is not None:
                            tables = format_return(
                                data=result['response']
                                [subcommand['subcommand_return_key']],
                                vertical=parsed_args['vertical']
                            )

                            for table in tables:
                                print(table)
                        else:
                            print('Command returned success')

                    sys.exit(0)
                except RuntimeError as err:
                    print('There was an error at runtime returned by the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)
                except ValueError as err:
                    print('There was an error with a parameter passed to the '
                          'API: "{0}"'.format(err))
                    sys.exit(1)


if __name__ == '__main__':
    main()
